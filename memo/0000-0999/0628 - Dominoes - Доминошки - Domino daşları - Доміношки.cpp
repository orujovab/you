#include <iostream>
#include <vector>
#include <string.h>

using namespace std;

int m, n, d[1 << 10][1 << 10];
long a[12][1 << 10];

//Возвращает значение pos - бита в числе x.
int bit(int x, int pos)
{
	if (pos < 0) return 0;
	return (x & (1 << pos));
}

//Генерирует все профили p2, в которые можно попасть из p1. Далее устанавливаем d[p1][p2] = 1.
void go(int p1, int p2, int pos)
{
	//Профиль p1 просмотрен до конца, до m - ой позиции.Значит из p1 можно получить p2.
	if (pos == m)
	{
		d[p1][p2] = 1;
		return;
	}
	//Если ячейка(бит) pos в профиле p1 не занятый.
	if (bit(p1, pos) == 0)
	{ //Тогда кладем горизонтальное домино.
		go(p1, p2 + (1LL << pos), pos + 1);

		//Если не занята и следующая, (pos + 1)-ая ячейка, то ложим вертикальную 
		//доминошку. При этом в профиль p2 ничего не добавляем, увеличиваем pos на 2.
		if (pos < m - 1 && bit(p1, pos + 1) == 0) go(p1, p2, pos + 2);
	}
	//Ячейка pos в профиле p1 занята, увеличиваем на 1 позицию pos в профиле p1.
	else go(p1, p2, pos + 1);
}

int main() {
	int i, p1, p2;
	scanf("%d %d", &m, &n);
	memset(d, 0, sizeof(d));
	memset(a, 0, sizeof(a));
	//Заполнение таблица переходов d. Для каждого профиля i находим все профили, в которые можно перейти.
	for (i = 0; i < (1 << m); i++) go(i, 0, 0);
	a[1][0] = 1;
	for (i = 2; i <= n + 1; i++)
		for (p1 = 0; p1 < (1 << m); p1++)
		{
			a[i][p1] = 0;
			for (p2 = 0; p2 < (1 << m); p2++) a[i][p1] += a[i - 1][p2] * d[p2][p1];
		}

	printf("%ld\n", a[n + 1][0]);
	return 0;
}
