#include <iostream>
#include <vector>

using namespace std;

vector<vector<int> > g, gr;
vector<int> used, top, Color;
int c, i, n, m, u, v, flag;

//Поиск в глубину на входном графе. В массив top заносим последовательность
//вершин, в которой поиск в глубину завершает их обработку.
void dfs1(int v)
{
	int i, to;
	used[v] = 1;
	for (i = 0; i < g[v].size(); i++)
	{
		to = g[v][i];
		if (!used[to]) dfs1(to);
	}
	top.push_back(v);
}

//Поиск в глубину на обратном графе. Все вершины, которые будут
//пройдены в результате рекурсивного вызова функции dfs2, принадлежат
//одной компоненте сильной связности. Красим все пройденные вершины цветом с.
void dfs2(int v, int c)
{
	int i, to;
	Color[v] = c;
	for (i = 0; i < gr[v].size(); i++)
	{
		to = gr[v][i];
		if (Color[to] == -1) dfs2(to, c);
	}
}

//Согласно импликативной связи u É v добавляем в граф ребра (u, v) и(!v, !u).
void AddEdge(int u, int v)
{
	g[u].push_back(v); g[v ^ 1].push_back(u ^ 1);
	gr[v].push_back(u); gr[u ^ 1].push_back(v ^ 1);
}

int main() {
	//Вершины входного графа нумеруются от 1 до n. Поскольку каждую вершину входного графа
	//следует расщепить на две, то поставим в соответствие вершине vi входного графа вершины
	//2i – 2 и 2i – 1 в графе импликаций. Вершины графа импликаций будут нумероваться с 0 до
	//2n – 1, причем четным вершинам будут соответствовать вершины vi, а нечетным их отрицания !vi.
	while (scanf("%d %d", &n, &m) == 2)
	{
		g.assign(2 * n, vector<int>());
		gr.assign(2 * n, vector<int>());
		for (i = 0; i < m; i++)
		{
			scanf("%d %d", &u, &v);
			if (u > 0) u = 2 * u - 2; else u = (2 * (-u) - 2) ^ 1;
			if (v > 0) v = 2 * v - 2; else v = (2 * (-v) - 2) ^ 1;
			AddEdge(u ^ 1, v);
		}
		//Запустим поиск в глубину из вершины 0, которой соответствует переменная x1. Вершине 1
		//соответствует переменная. Если по окончании поиска станет used[1] = 1, то существует
		//путь из 0 в 1 или имеет место импликация. Для ее истинности необходимо выбрать x1 = 0.
		//Поскольку Карлу соответствует переменная x1 и он должен пройти в следующий раунд, то
		//должно быть x1 = 1. То есть при used[1] = 1 Карл не сможет взломать систему.
		top.clear();
		used.assign(2 * n, 0);
		dfs1(0);
		if (used[1])
		{
			printf("no\n");
			continue;
		}
		//Запускаем поиск в глубину на графе импликаций. Последовательность, в
		//которой завершается обработка вершин графа, сохраняется в массиве top.
		top.clear();
		used.assign(2 * n, 0);
		for (i = 0; i < 2 * n; i++) if (!used[i]) dfs1(i);

		//Запускаем поиск в глубину на обратном графе. Вершины обратного графа рассматриваем в
		//порядке обхода массива top с конца в начало. Вершины, входящие в одну компоненту сильной
		//связности, красим одним и тем же цветом.Текущий цвет раскраски находится в переменной с.
		Color.assign(2 * n, -1);
		for (i = 0, c = 0; i < 2 * n; i++)
		{
			v = top[2 * n - i - 1];
			if (Color[v] == -1) dfs2(v, c++);
		}
		//Если некоторая переменная и ее отрицание входят в одну сильно связную компоненту
		//(соответствующие ей вершины i и i XOR 1 покрашены одним цветом), то решения не существует.
		for (flag = i = 0; i < 2 * n; i += 2) {
			if (Color[i] == Color[i ^ 1])
			{
				flag = 1;
				break;
			}
		}
		printf("%s\n", flag ? "no" : "yes");
	}
	return 0;
}
