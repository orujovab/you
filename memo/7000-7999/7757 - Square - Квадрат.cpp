#include <iostream>
#include <string.h>
#include <algorithm>

using namespace std;

int main() {
	int i, j, n, cnt, val, Size, dp[1001][1001];
	//Переменная size хранит размер наибольшего квадрата, cnt - количество раз,
	//которое он встречается в куске. Инициализируем массив dp нулями.
	scanf("%d", &n);
	memset(dp, 0, sizeof dp);
	Size = cnt = 0;
	//Пересчитываем массив dp по возрастанию строк,
	//ячейки в каждой строке – по возрастанию столбцов.
	for (i = 1; i <= n; i++)
		for (j = 1; j <= n; j++)
		{
			scanf("%d", &val);
			//Пусть все значения массива dp до клетки(i, j) уже посчитаны. Читаем
			//очередное значение val = m[i][j] (входную матрицу в памяти не держим,
			//читаем и обрабатываем ее на лету). Поскольку изначально мы обнулили
			//массив dp, то при val = 0 значение dp[i][j] будет оставаться равным 0.
			if (val == 1)
			{
				dp[i][j] = min(min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;
				//Пересчитываем значения size и cnt для очередного квадрата размером dp[i][j].
				if (dp[i][j] == Size) cnt++;
				if (dp[i][j] > Size) { Size = dp[i][j]; cnt = 1; }
			}
		}
	printf("%d\n", Size * cnt);
	return 0;
}
