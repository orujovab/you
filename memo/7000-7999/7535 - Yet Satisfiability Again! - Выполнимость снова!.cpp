#include <iostream>
#include <vector>

using namespace std;

vector<vector<int> > v;

int main() {
	int i, j, k, n, m, s, p, bit, sat = 0, val, tests;
	char ch;
	scanf("%d", &tests);
	while (tests--)
	{
		scanf("%d %d\n", &n, &m);
		v.clear(); v.resize(m);
		//Читаем правила и преобразовываем их в удобный для дальнейшей обработки формат.
		for (i = 0; i < m; i++)
		{
			scanf("%c", &ch);
			while (true)
			{
				if (ch == '~')
				{
					scanf("X%d", &val);
					val = -val;
				}
				else scanf("%d", &val);
				v[i].push_back(val);
				//Читаем символ за переменной. Если это конец строки
				//(ch = '\n'), то завершаем обработку текущего правила.
				scanf("%c", &ch);
				if (ch == '\n') break;
				//Читаем символ v, пробел и следующий символ(который равен '~' или 'X').
				scanf("%c%c%c", &ch, &ch, &ch);
			}
		}
		//Генерируем все кортежи(X1, X2, …, Xn) из нулей и
		//единиц длины n. Кортежем является двоичный код числа i.
		for (i = 0; i < (1 << n); i++)
		{
			//Проверяем выполнимость правил на кортеже, который задается двоичным кодом числа i.
			sat = 1;
			for (k = 0; k < m; k++)
			{
				//Проверяем выполнимость k - го правила.
				s = 0;
				for (j = 0; j < v[k].size(); j++)
				{
					p = v[k][j];
					//Правило содержит переменную X | p | . Если p < 0, то переменная X | p | входит
					//в k - ое правило с отрицанием.В переменной bit вычисляем ее значение на текущем кортеже.
					bit = (i & 1 << abs(p) - 1) > 0;
					if (p < 0) bit = 1 - bit;
					s |= bit;
				}
				//Если текущее правило не выполнимо(s = 0), то проверяем следующий кортеж.
				sat &= s;
				if (!sat) break;
			}
			//sat = 1, если все правила выполнимы.Завершаем перебор, нет смысла его продолжать дальше.
			if (sat) break;
		}
		//В зависимости от значения sat выводим ответ.
		puts(sat ? "satisfiable" : "unsatisfiable");
	}
	return 0;
}
