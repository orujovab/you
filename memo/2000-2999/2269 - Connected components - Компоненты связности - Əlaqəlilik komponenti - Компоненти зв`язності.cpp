#include <iostream> 

using namespace std;

int i, j, n, cnt, value, mas[101];

//Функция Repr(n) возвращает номер вершины – представителя множества,
//содержащего вершину n. Двигаемся по указателю на следующий элемент,
//пока не встретим представителя множества(его указатель указывает на него самого).
int Repr(int n)
{
	while (n != mas[n]) n = mas[n];
	return n;
}

//Функция Union(x, y) объединяет два множества, которые содержат вершины x и y.
//Ищем представителей множеств, содержащих x и y. Пусть этими представителями
//будут x1 и y1. Если x1 = y1, то x и y содержатся в одном множестве, и в таком
//случае ничего делать не надо.Иначе указатель представителя x1 перенаправляем на y1.
void Union(int x, int y)
{
	int x1 = Repr(x), y1 = Repr(y);
	if (x1 == y1) return;
	mas[x1] = y1;
}

int main() {
	//Изначально каждая вершина указывает сама на себя(mas[i] = i).
	scanf("%d", &n);
	for (i = 1; i <= n; i++) mas[i] = i;

	//Читаем матрицу смежности. Для каждого ребра (i, j), где i < j,
	//совершаем объединение множеств, содержащих вершины i и j.
	for (i = 1; i <= n; i++) {
		for (j = 1; j <= n; j++)
		{
			scanf("%d", &value);
			if (i > j) continue;
			if (value) Union(i, j);
		}
	}
	//Подсчитываем количество компонент связности в переменной count. Оно равно
	//количеству вершин – представителей множеств(которые указывают сами на себя).
	for (i = 1; i <= n; i++) if (mas[i] == i) cnt++;
	printf("%d\n", cnt);
	return 0;
}
