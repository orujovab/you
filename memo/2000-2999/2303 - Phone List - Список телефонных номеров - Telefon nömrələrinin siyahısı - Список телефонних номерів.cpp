#include <iostream>
#include <string.h>
#include <vector>

using namespace std;

int i, n, t, flag;
char number[10];

struct item
{
	int leaf, next[10];
	item()
	{
		for (size_t i = 0; i < 10; i++) next[i] = -1;
		leaf = 0;
	}
};
//Бор хранится в массиве trie.
vector<item> trie;

//Вставка номера телефона, который задается в строке s, в бор. Переменная
//flag устанавливается в 1, если обнаруживается несоответствие номеров.
void Insert(char *s)
{
	int i, v = 0;
	item temp;
	if (flag) return;

	//Проходим по всем символам слова s, вставляя его в бор.
	for (i = 0; i < strlen(s); ++i)
	{

		//Если текущее слово s еще не обработано до конца, а мы уже находимся в вершине
		//trie[v], являющейся концом некоторого другого слова t, то t является префиксом s.
		//Набор телефонных номеров является несовместным, устанавливаем flag равным 1.

		if (trie[v].leaf) { flag = 1; return; }
		char c = s[i] - '0';

		//Если из теущей вершины trie[v] нет перехода по символу c, то создаем новую вершину бора.
		if (trie[v].next[c] == -1)
		{
			trie[v].next[c] = trie.size();
			trie.push_back(temp);
		}
		//Совершаем переход по символу c.
		v = trie[v].next[c];
	}

	//Обработка слова s закончена. Если из текущей вершины trie[v] можно попасть
	//еще куда - нибудь (существует i, для которого trie[v].next[i] ≠ - 1), то
	//существует слово t, для которого s будет префиксом.Устанавливаем flag = 1.
	for (i = 0; i < 10; i++) if (trie[v].next[i] != -1) flag = 1;

	//Если обработка слова s закончена в вершине, которая уже является концом некоторого
	//телефонного номера t, то номера s и t совпадают.
	if (trie[v].leaf) flag = 1;

	//Отмечаем факт завершения обработки слова s в вершине trie[v].
	trie[v].leaf = true;
}

int main() {
	scanf("%d", &t);
	while (t--)
	{
		scanf("%d\n", &n);

		//Чистим бор. Устанавливаем его длину равной единице : это единственная вершина – корень бора.
		//Изначально все телефонные номера считаются совместимыми, присваиваем переменной flag значение 0.
		trie.clear(); trie.resize(1);
		flag = 0;

		//Читаем телефонные номера. Заносим их в бор. Даже если на каком - то этапе обнаружена несовместимость
		//номеров – все равно следует дочитать номера до конца, так как входные данные содержат несколько тестов.
		for (i = 0; i < n; i++)
		{
			gets(number);
			Insert(number);
		}
		//В зависимости от значения flag выводим ответ.
		printf(flag ? "NO\n" : "YES\n");
	}
	return 0;
}
