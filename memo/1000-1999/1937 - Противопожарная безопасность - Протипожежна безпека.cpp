#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<vector<int> > g, gr;
vector<int> used, top, color, repr;
int a, b, c, i, j, n, m, v;
bool flag;

//Поиск в глубину на входном графе. В массив top заносим последовательность
//вершин, в которой поиск в глубину завершает их обработку.
void dfs1(int v)
{
	int i, to;
	used[v] = 1;
	for (i = 0; i < g[v].size(); i++)
	{
		to = g[v][i];
		if (!used[to]) dfs1(to);
	}
	top.push_back(v);
}

//Поиск в глубину на обратном графе. Все вершины, которые будут пройдены в результате рекурсивного
//вызова функции dfs2, принадлежат одной компоненте сильной связности. Красим все пройденные вершины
//цветом с. Вершины, находящиеся в одной сильно связной компоненте, имеют одинаковый цвет. Для каждого
//цвета с запомним в массиве repr ее представителя - любой номер вершины, покрашенной цветом с.
void dfs2(int v, int c)
{
	int i, to;
	color[v] = c;
	repr[c] = v;
	for (i = 0; i < gr[v].size(); i++)
	{
		to = gr[v][i];
		if (color[to] == -1) dfs2(to, c);
	}
}

int main() {

	scanf("%d %d", &n, &m);
	g.assign(n + 1, vector<int>());
	gr.assign(n + 1, vector<int>());
	for (i = 0; i < m; i++)
	{
		scanf("%d %d", &a, &b);
		g[a].push_back(b); gr[b].push_back(a);
	}
	//Запускаем поиск в глубину на входном графе. Последовательность, в
	//которой завершается обработка вершин графа, сохраняется в массиве top.
	used.assign(n + 1, 0);
	for (i = 1; i <= n; i++) if (!used[i]) dfs1(i);

	//Запускаем поиск в глубину на обратном графе. Вершины обратного графа рассматриваем в порядке
	//обхода массива top справа налево (с конца в начало). Вершины, входящие в одну компоненту
	//сильной связности, красим одним и тем же цветом.Текущий цвет раскраски находится в переменной с.
	color.assign(n + 1, -1);
	repr.assign(n + 1, -1);
	for (c = 0, i = 1; i <= n; i++)
	{
		v = top[n - i];
		if (color[v] == -1) dfs2(v, c++);
	}
	//Переменная c содержит количество компонент связности.
	used.assign(c, 1);
	for (i = 1; i < g.size(); i++) {
		for (j = 0; j < g[i].size(); j++)
		{
			int to = g[i][j];
			//Перебираем все ребра графа(i, to). Проверяем, лежат ли вершины i и to в разных сильно связных
			//компонентах. Это так, если они покрашены разными цветами. В этом случае нет смысла строить
			//пожарную станцию в компоненте связности цвета color[i], поэтому установим used[color[i]] = 0.
			if (color[i] != color[to]) used[color[i]] = 0;
		}
	}
	//Подсчитаем количество компонент c, в которых следует построить пожарную.
	for (c = i = 0; i < used.size(); i++) if (used[i]) c++;
	printf("%d\n", c);

	//Для каждой компоненты цвета i, из которой не выходят ребра, выведем по одному ее представителю
	//(значение repr[i]) – это и будут номера домов, возле которых следует построить пожарные станции.
	for (flag = i = 0; i < used.size(); i++) {
		if (used[i])
		{
			if (flag) printf(" ");
			printf("%d", repr[i]);
			flag = 1;
		}
	}
	printf("\n");
	return 0;
}
