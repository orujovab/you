#include <iostream>
#include <algorithm>

using namespace std;

#define MAX 1001
#define PI acos(-1.0)

int main() {
	double alfa, s, sq, r2, res, d[MAX];
	int n, r, points;
	//Пока не достигнем конца файла, читаем входные данные.
	while (scanf("%d %d", &n, &r), n + r)
	{
		//Заносим радианную меру точек в массив d, сортируем массив d по возрастанию.
		for (int i = 0; i < n; i++) scanf("%lf", &d[i]), d[i] = d[i] * PI / 180;
		sort(d, d + n);

		//В переменную res изначально заносим площадь, равную площади  кругов радиуса r,
		//то есть значение C(n,3)*PI*r^2=n(n-1)(n-2)(n-2)PI*r^2/6.Переменной r2 присвоим значение r^2/2,
		//а sq площадь одного круга, то есть PI*r^2.
		res = PI*r*r*n * (n - 1) * (n - 2) / 6;
		r2 = r * r / 2.0;
		sq = PI * r * r;

		//При помощи индексов i и j совершаем перебор пар точек.
		for (int i = 0; i < n; i++)
			for (int j = i + 1; j < n; j++)
			{
				//Вычисляем угол alfa между точками i и j, который равен d[j] – d[i].
				//Если alfa меньше, то при движении от i к j мы проходим по меньшему сегменту
				//и его площадь равна PI*r^2-0.5r^2(alfa'-sinalfa'), alfa'=2PI-alfa. Иначе при движении от i к j
				//мы проходим по большему сегменту и в таком случае его площадь равна, где положено.
				//В обоих случаях переменной s присваивается площадь сегмента,
				//который мы проходим при движении от Pi к Pj против часовой стрелки.
				alfa = d[j] - d[i];
				if (alfa < PI) s = r2 * (alfa - sin(alfa));
				else
				{
					alfa = 2 * PI - alfa;
					s = sq - r2 * (alfa - sin(alfa));
				}
				//Количество точек points, лежащих на сегменте, площадь которого, равно n –(j – i + 1).
				//Таким образом из значения res необходимо вычесть points раз площадь сегмента s.
				points = n - (j - i + 1);
				res -= s * points;
				//Количество точек, лежащих на сегменте площади s, равно points = n – points – 2.
				//Площадь противоположного сегмента равна sq – s.Остается вычесть ее из res points раз.
				points = n - points - 2;
				res -= (sq - s) * points;
			}

		printf("%.0lf\n", res);
	}
	return 0;
}
