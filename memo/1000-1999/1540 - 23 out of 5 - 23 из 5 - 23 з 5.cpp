#include <iostream>
#include <algorithm>
#include <string.h>

using namespace std;

int a[5], Found;

//Функция RunSum вычисляет значение выражения, операнды которого находятся в массиве a.
//Между операндами вставляются знаки всевозможных операций и вычисляются полученные выражения
//при помощи техники бектрекинга.Если значение одного из выражений равно 23, то функция возвращает 1, иначе 0.
int RunSum(int Sum, int index)
{
	if (index == 5)
	{
		if (Sum == 23) return 1;
		return 0;
	}
	if (RunSum(Sum + a[index], index + 1)) return 1;
	if (RunSum(Sum - a[index], index + 1)) return 1;
	if (RunSum(Sum*a[index], index + 1)) return 1;
	return 0;
}

int main() {
	//Читаем пятерку чисел в массив a. Запускаем процедуру генерации всех перестановок.
	//Поскольку функция next_permutation генерирует перестановки в лексикографическом порядке,
	//то первой должна быть наименьшая перестановка. Наименьшей будет перестановка, у которой
	//числа образуют неубывающую последовательность. То есть перед генерацией перестановок числа
	//в массиве а следует отсортировать по неубыванию (если этого не сделать, то могут быть
	//рассмотрены не все перестановки). Для каждой перестановки запускаем функцию RunSum, которая
	//выясняет, можно ли между числами этой перестановки расставить знаки операций так, чтобы
	//получить значение 23. Если переменная Found установилась в 1, то выводим ‘Possible’, иначе ‘Impossible’.
	while (scanf("%d %d %d %d %d", &a[0], &a[1], &a[2], &a[3], &a[4]), a[0] + a[1] + a[2] + a[3] + a[4])
	{
		sort(a, a + 5);
		Found = 0;
		do {
			if (Found = RunSum(a[0], 1)) break;
		} while (next_permutation(a, a + 5));
		printf(Found ? "Possible\n" : "Impossible\n");
		memset(a, 0, sizeof a);
	}
	return 0;
}
