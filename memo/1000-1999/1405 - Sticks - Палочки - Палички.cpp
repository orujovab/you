#include <iostream>
#include <algorithm>

using namespace std;

#define MAX 16

int n, a[MAX], sum[1 << MAX];
bool can[1 << MAX];

int main() {
	scanf("%d", &n);
	for (int i = 0; i < n; i++) scanf("%d", &a[i]);

	//Перебираем все подмножества палочек, вычисляем суммарную длину каждого подмножества.
	for (int i = 0; i < 1 << n; i++)
		for (int j = 0; j < n; j++)
			if (i & 1 << j) sum[i] += a[j];

	//Перебираем все подмножества всех множеств палочек. Если для множества I палочек имеется такое подмножество J Ì I,
	//что суммарная длина палочек в J в два раза меньше суммарной длины палочек в I, то установим can[I] = true.
	//Подмножество палочек из I можно использовать в качестве противоположных сторон прямоугольника.
	for (int i = 1; i < 1 << n; i++)
	{
		int s = sum[i];
		for (int j = i; j > 0; j = (j - 1) & i)
			if (sum[j] * 2 == s)
			{
				can[i] = true;
				break;
			}
	}
	//Перебираем все подмножества всех множеств палочек. Если для множества I палочек имеется такое подмножество J Ì I,
	//что can[J] = can[I xor J] = true, то получим одно из возможных распределений палочек для горизонтальных и
	//вертикальных сторон.Длины сторон прямоугольника равны sum[j] / 2 и sum[i ^ j] / 2.

	long res = 0;
	for (int i = 1; i < 1 << n; i++)
		for (int j = i; j > 0; j = j - 1 & i)
			if (can[j] && can[i ^ j]) res = max(res, sum[j] / 2L * sum[i ^ j] / 2);

	printf("%ld\n", res);
	return 0;
}
