#include <iostream>
#include <string.h>
#include <algorithm>

using namespace std;

int *m;
long i, n, swaps;

//Слияние отсортированных массивов a[bL] ... a[bR] и a[cL] ... a[cR] в a[bL] ... a[cR].
//Отметим, что у нас всегда bR + 1 = cL.Для слияния используем дополнительный массив res.
void merge(int *a, int bL, int bR, int cL, int cR)
{
	//Занесем в len количество сливаемых элементов.Создадим массив res(буфер), в который будут сливаться элементы.

	int i = 0, Left = bL, len = cR - bL + 1;
	int *res = new int[len];
	//Текущей просматриваемой позицией в первой последовательности является bL, во второй cL.
	//То есть на каждой итерации сравниваются a[bL] и a[cL]. Меньшее из этих значений заносится
	//в буфер res. По мере добавленияя элементов в буфер значения bL и cL увеличиваются на 1.
	//Как только одно из них дойдет до конца последовательности (bL станет больше bR или cL станет больше cR),
	//цикл заканчивается. Это означает, что элементы одной из сливаемых последовательностей уже полностью перенесены в буфер.
	//Количество инверсий swaps изменяется при перенесении элемента второй последовательности в буфер.
	//При этом swaps увеличивается на число еще неслитых элементов первой последовательности, равное bR – bL + 1
	//(из первой последовательности еще не перенесены в буфер элементы a[bL ..bR]).

	while (bL <= bR && cL <= cR)
		if (a[bL] <= a[cL])  res[i++] = a[bL++];
		else res[i++] = a[cL++], swaps += bR - bL + 1;

		//Одна из сливаемых последовательностей закончилась. Следует скопировать в конец буфера остаток другой последовательности.
		while (bL <= bR) res[i++] = a[bL++];
		while (cL <= cR) res[i++] = a[cL++];

		//Копируем все содержимое буфера в массив а, начиная с ячейки Left.
		memcpy(a + Left, res, len * sizeof(int));

		//Удаляем буфер – весь массив res.
		delete[] res;
}

//Сортируем массив a[left ... right] методом “разделяй и властвуй”. Для этого разделим его на две части a[left ... middle]
//и a[middle + 1 ... right], отсортируем отдельно каждую из них, после чего произведем слияние.
void mergeSort(int *a, int left, int right)
{
	if (left >= right) return;
	int middle = (left + right) / 2;
	mergeSort(a, left, middle);
	mergeSort(a, middle + 1, right);
	merge(a, left, middle, middle + 1, right);
}

int main() {
	//Выделяем память под входной массив, считываем его и запускаем
	//сортировку слиянием, в которой подсчитываем количество инверсий swaps.
	while (scanf("%d", &n), n)
	{
		m = new int[n];
		for (swaps = i = 0; i < n; i++) scanf("%d", &m[i]);
		mergeSort(m, 0, n - 1);
		printf("%ld\n", swaps);
		delete[] m;
	}
	return 0;
}
